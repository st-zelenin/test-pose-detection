{"version":3,"sources":["js/LZWEncoder.js","js/NeuQuant.js","js/GIFEncoder.js","movement-augmenters/hat.ts","gif_worker.ts"],"names":["LZWEncoder","exports","imgW","imgH","pixAry","initCodeSize","remaining","curPixel","n_bits","maxcode","g_init_bits","ClearCode","EOFCode","a_count","htab","codetab","free_ent","clear_flg","cur_accum","cur_bits","masks","accum","width","height","pixels","color_depth","Math","max","char_out","c","outs","flush_char","cl_block","cl_hash","output","hsize","i","compress","init_bits","fcode","ent","disp","hshift","MAXCODE","nextPixel","outer_loop","encode","os","writeByte","writeBytes","code","apply","arguments","NeuQuant","alphadec","thepicture","lengthcount","samplefac","network","netindex","bias","freq","radpower","thepic","len","sample","p","Array","netbiasshift","intbias","unbiasnet","map","b","g","r","j","dist","a","bestd","best","process","colorMap","radius","rad","alpha","step","delta","samplepixels","pix","lim","initrad","contest","altersingle","alterneigh","learn","smallpos","smallval","q","previouscol","startpos","netsize","inxbuild","index","k","l","lo","hi","m","alphabiasshift","e","n","biasdist","betafreq","bestpos","bestbiaspos","bestbiasd","intbiasshift","GIFEncoder","chr","String","fromCharCode","ByteArray","bin","prototype","getData","v","length","val","push","writeUTFBytes","string","charCodeAt","array","offset","transIndex","out","image","indexedPixels","colorDepth","colorTab","transparent","repeat","delay","started","usedEntry","palSize","dispose","closeStream","firstFrame","sizeSet","comment","reset","setDelay","ms","round","setDispose","setRepeat","iter","setTransparent","setComment","addFrame","im","is_imageData","Error","ok","ImageData","data","setSize","Uint8ClampedArray","console","log","getImageData","canvas","getImagePixels","analyzePixels","writeLSD","writePalette","writeNetscapeExt","writeGraphicCtrlExt","writeCommentExt","writeImageDesc","writePixels","download","filename","undefined","endsWith","templink","document","createElement","href","URL","createObjectURL","Blob","Uint8Array","type","click","finish","setFrameRate","fps","setQuality","quality","w","h","start","cont","nPix","nq","findClosest","minpos","dmin","dr","dg","db","d","count","transp","WriteShort","pValue","stream","setProperties","has_start","is_first"],"mappings":"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","file":"gif_worker.933bf1d5.js","sourceRoot":"..","sourcesContent":["/**\r\n * This class handles LZW encoding\r\n * Adapted from Jef Poskanzer's Java port by way of J. M. G. Elliott.\r\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\r\n * @author Thibault Imbert (AS3 version - bytearray.org)\r\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\r\n * @version 0.1 AS3 implementation\r\n */\r\n\r\nLZWEncoder = function() {\r\n\r\n\tvar exports = {};\r\n\tvar EOF = -1;\r\n\tvar imgW;\r\n\tvar imgH;\r\n\tvar pixAry;\r\n\tvar initCodeSize;\r\n\tvar remaining;\r\n\tvar curPixel;\r\n\r\n\t// GIFCOMPR.C - GIF Image compression routines\r\n\t// Lempel-Ziv compression based on 'compress'. GIF modifications by\r\n\t// David Rowley (mgardi@watdcsu.waterloo.edu)\r\n\t// General DEFINEs\r\n\r\n\tvar BITS = 12;\r\n\tvar HSIZE = 5003; // 80% occupancy\r\n\r\n\t// GIF Image compression - modified 'compress'\r\n\t// Based on: compress.c - File compression ala IEEE Computer, June 1984.\r\n\t// By Authors: Spencer W. Thomas (decvax!harpo!utah-cs!utah-gr!thomas)\r\n\t// Jim McKie (decvax!mcvax!jim)\r\n\t// Steve Davies (decvax!vax135!petsd!peora!srd)\r\n\t// Ken Turkowski (decvax!decwrl!turtlevax!ken)\r\n\t// James A. Woods (decvax!ihnp4!ames!jaw)\r\n\t// Joe Orost (decvax!vax135!petsd!joe)\r\n\r\n\tvar n_bits; // number of bits/code\r\n\tvar maxbits = BITS; // user settable max # bits/code\r\n\tvar maxcode; // maximum code, given n_bits\r\n\tvar maxmaxcode = 1 << BITS; // should NEVER generate this code\r\n\tvar htab = [];\r\n\tvar codetab = [];\r\n\tvar hsize = HSIZE; // for dynamic table sizing\r\n\tvar free_ent = 0; // first unused entry\r\n\r\n\t// block compression parameters -- after all codes are used up,\r\n\t// and compression rate changes, start over.\r\n\r\n\tvar clear_flg = false;\r\n\r\n\t// Algorithm: use open addressing double hashing (no chaining) on the\r\n\t// prefix code / next character combination. We do a variant of Knuth's\r\n\t// algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime\r\n\t// secondary probe. Here, the modular division first probe is gives way\r\n\t// to a faster exclusive-or manipulation. Also do block compression with\r\n\t// an adaptive reset, whereby the code table is cleared when the compression\r\n\t// ratio decreases, but after the table fills. The variable-length output\r\n\t// codes are re-sized at this point, and a special CLEAR code is generated\r\n\t// for the decompressor. Late addition: construct the table according to\r\n\t// file size for noticeable speed improvement on small files. Please direct\r\n\t// questions about this implementation to ames!jaw.\r\n\r\n\tvar g_init_bits;\r\n\tvar ClearCode;\r\n\tvar EOFCode;\r\n\r\n\t// output\r\n\t// Output the given code.\r\n\t// Inputs:\r\n\t// code: A n_bits-bit integer. If == -1, then EOF. This assumes\r\n\t// that n_bits =< wordsize - 1.\r\n\t// Outputs:\r\n\t// Outputs code to the file.\r\n\t// Assumptions:\r\n\t// Chars are 8 bits long.\r\n\t// Algorithm:\r\n\t// Maintain a BITS character long buffer (so that 8 codes will\r\n\t// fit in it exactly). Use the VAX insv instruction to insert each\r\n\t// code in turn. When the buffer fills up empty it and start over.\r\n\r\n\tvar cur_accum = 0;\r\n\tvar cur_bits = 0;\r\n\tvar masks = [0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF];\r\n\r\n\t// Number of characters so far in this 'packet'\r\n\tvar a_count;\r\n\r\n\t// Define the storage for the packet accumulator\r\n\tvar accum = [];\r\n\r\n\tvar LZWEncoder = exports.LZWEncoder = function LZWEncoder(width, height, pixels, color_depth) {\r\n\t\timgW = width;\r\n\t\timgH = height;\r\n\t\tpixAry = pixels;\r\n\t\tinitCodeSize = Math.max(2, color_depth);\r\n\t};\r\n\r\n\t// Add a character to the end of the current packet, and if it is 254\r\n\t// characters, flush the packet to disk.\r\n\tvar char_out = function char_out(c, outs) {\r\n\t\taccum[a_count++] = c;\r\n\t\tif (a_count >= 254) flush_char(outs);\r\n\t};\r\n\r\n\t// Clear out the hash table\r\n\t// table clear for block compress\r\n\r\n\tvar cl_block = function cl_block(outs) {\r\n\t\tcl_hash(hsize);\r\n\t\tfree_ent = ClearCode + 2;\r\n\t\tclear_flg = true;\r\n\t\toutput(ClearCode, outs);\r\n\t};\r\n\r\n\t// reset code table\r\n\tvar cl_hash = function cl_hash(hsize) {\r\n\t\tfor (var i = 0; i < hsize; ++i) htab[i] = -1;\r\n\t};\r\n\r\n\tvar compress = exports.compress = function compress(init_bits, outs) {\r\n\r\n\t\tvar fcode;\r\n\t\tvar i; /* = 0 */\r\n\t\tvar c;\r\n\t\tvar ent;\r\n\t\tvar disp;\r\n\t\tvar hsize_reg;\r\n\t\tvar hshift;\r\n\r\n\t\t// Set up the globals: g_init_bits - initial number of bits\r\n\t\tg_init_bits = init_bits;\r\n\r\n\t\t// Set up the necessary values\r\n\t\tclear_flg = false;\r\n\t\tn_bits = g_init_bits;\r\n\t\tmaxcode = MAXCODE(n_bits);\r\n\r\n\t\tClearCode = 1 << (init_bits - 1);\r\n\t\tEOFCode = ClearCode + 1;\r\n\t\tfree_ent = ClearCode + 2;\r\n\r\n\t\ta_count = 0; // clear packet\r\n\r\n\t\tent = nextPixel();\r\n\r\n\t\thshift = 0;\r\n\t\tfor (fcode = hsize; fcode < 65536; fcode *= 2)\r\n\t\t\t++hshift;\r\n\t\thshift = 8 - hshift; // set hash code range bound\r\n\r\n\t\thsize_reg = hsize;\r\n\t\tcl_hash(hsize_reg); // clear hash table\r\n\r\n\t\toutput(ClearCode, outs);\r\n\r\n\t\touter_loop: while ((c = nextPixel()) != EOF) {\r\n\t\t\tfcode = (c << maxbits) + ent;\r\n\t\t\ti = (c << hshift) ^ ent; // xor hashing\r\n\r\n\t\t\tif (htab[i] == fcode) {\r\n\t\t\t\tent = codetab[i];\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\telse if (htab[i] >= 0) { // non-empty slot\r\n\r\n\t\t\t\tdisp = hsize_reg - i; // secondary hash (after G. Knott)\r\n\t\t\t\tif (i === 0) disp = 1;\r\n\r\n\t\t\t\tdo {\r\n\t\t\t\t\tif ((i -= disp) < 0)\r\n\t\t\t\t\t\ti += hsize_reg;\r\n\r\n\t\t\t\t\tif (htab[i] == fcode) {\r\n\t\t\t\t\t\tent = codetab[i];\r\n\t\t\t\t\t\tcontinue outer_loop;\r\n\t\t\t\t\t}\r\n\t\t\t\t} while (htab[i] >= 0);\r\n\t\t\t}\r\n\r\n\t\t\toutput(ent, outs);\r\n\t\t\tent = c;\r\n\t\t\tif (free_ent < maxmaxcode) {\r\n\t\t\t\tcodetab[i] = free_ent++; // code -> hashtable\r\n\t\t\t\thtab[i] = fcode;\r\n\t\t\t}\r\n\t\t\telse cl_block(outs);\r\n\t\t}\r\n\r\n\t\t// Put out the final code.\r\n\t\toutput(ent, outs);\r\n\t\toutput(EOFCode, outs);\r\n\t};\r\n\r\n\t// ----------------------------------------------------------------------------\r\n\tvar encode = exports.encode = function encode(os) {\r\n\t\tos.writeByte(initCodeSize); // write \"initial code size\" byte\r\n\t\tremaining = imgW * imgH; // reset navigation variables\r\n\t\tcurPixel = 0;\r\n\t\tcompress(initCodeSize + 1, os); // compress and write the pixel data\r\n\t\tos.writeByte(0); // write block terminator\r\n\t};\r\n\r\n\t// Flush the packet to disk, and reset the accumulator\r\n\tvar flush_char = function flush_char(outs) {\r\n\t\tif (a_count > 0) {\r\n\t\t\touts.writeByte(a_count);\r\n\t\t\touts.writeBytes(accum, 0, a_count);\r\n\t\t\ta_count = 0;\r\n\t\t}\r\n\t};\r\n\r\n\tvar MAXCODE = function MAXCODE(n_bits) {\r\n\t\treturn (1 << n_bits) - 1;\r\n\t};\r\n\r\n\t// ----------------------------------------------------------------------------\r\n\t// Return the next pixel from the image\r\n\t// ----------------------------------------------------------------------------\r\n\r\n\tvar nextPixel = function nextPixel() {\r\n\t\tif (remaining === 0) return EOF;\r\n\t\t--remaining;\r\n\t\tvar pix = pixAry[curPixel++];\r\n\t\treturn pix & 0xff;\r\n\t};\r\n\r\n\tvar output = function output(code, outs) {\r\n\r\n\t\tcur_accum &= masks[cur_bits];\r\n\r\n\t\tif (cur_bits > 0) cur_accum |= (code << cur_bits);\r\n\t\telse cur_accum = code;\r\n\r\n\t\tcur_bits += n_bits;\r\n\r\n\t\twhile (cur_bits >= 8) {\r\n\t\t\tchar_out((cur_accum & 0xff), outs);\r\n\t\t\tcur_accum >>= 8;\r\n\t\t\tcur_bits -= 8;\r\n\t\t}\r\n\r\n\t\t// If the next entry is going to be too big for the code size,\r\n\t\t// then increase it, if possible.\r\n\r\n\t\tif (free_ent > maxcode || clear_flg) {\r\n\r\n\t\t\tif (clear_flg) {\r\n\r\n\t\t\t\tmaxcode = MAXCODE(n_bits = g_init_bits);\r\n\t\t\t\tclear_flg = false;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t++n_bits;\r\n\t\t\t\tif (n_bits == maxbits) maxcode = maxmaxcode;\r\n\t\t\t\telse maxcode = MAXCODE(n_bits);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (code == EOFCode) {\r\n\r\n\t\t\t// At EOF, write the rest of the buffer.\r\n\t\t\twhile (cur_bits > 0) {\r\n\t\t\t\tchar_out((cur_accum & 0xff), outs);\r\n\t\t\t\tcur_accum >>= 8;\r\n\t\t\t\tcur_bits -= 8;\r\n\t\t\t}\r\n\r\n\t\t\tflush_char(outs);\r\n\t\t}\r\n\t};\r\n\r\n\tLZWEncoder.apply(this, arguments);\r\n\treturn exports;\r\n};\r\n","/*\r\n * NeuQuant Neural-Net Quantization Algorithm\r\n * ------------------------------------------\r\n *\r\n * Copyright (c) 1994 Anthony Dekker\r\n *\r\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\r\n * \"Kohonen neural networks for optimal colour quantization\" in \"Network:\r\n * Computation in Neural Systems\" Vol. 5 (1994) pp 351-367. for a discussion of\r\n * the algorithm.\r\n *\r\n * Any party obtaining a copy of these files from the author, directly or\r\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\r\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal in\r\n * this software and documentation files (the \"Software\"), including without\r\n * limitation the rights to use, copy, modify, merge, publish, distribute,\r\n * sublicense, and/or sell copies of the Software, and to permit persons who\r\n * receive copies from any such party to do so, with the only requirement being\r\n * that this copyright notice remain intact.\r\n */\r\n\r\n/*\r\n * This class handles Neural-Net quantization algorithm\r\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\r\n * @author Thibault Imbert (AS3 version - bytearray.org)\r\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\r\n * @version 0.1 AS3 implementation\r\n */\r\n\r\nNeuQuant = function() {\r\n\r\n\tvar exports = {};\r\n\tvar netsize = 256; /* number of colours used */\r\n\r\n\t/* four primes near 500 - assume no image has a length so large */\r\n\t/* that it is divisible by all four primes */\r\n\r\n\tvar prime1 = 499;\r\n\tvar prime2 = 491;\r\n\tvar prime3 = 487;\r\n\tvar prime4 = 503;\r\n\tvar minpicturebytes = (3 * prime4); /* minimum size for input image */\r\n\r\n\t/*\r\n\t * Program Skeleton ---------------- [select samplefac in range 1..30] [read\r\n\t * image from input file] pic = (unsigned char*) malloc(3*width*height);\r\n\t * initnet(pic,3*width*height,samplefac); learn(); unbiasnet(); [write output\r\n\t * image header, using writecolourmap(f)] inxbuild(); write output image using\r\n\t * inxsearch(b,g,r)\r\n\t */\r\n\r\n\t/*\r\n\t * Network Definitions -------------------\r\n\t */\r\n\r\n\tvar maxnetpos = (netsize - 1);\r\n\tvar netbiasshift = 4; /* bias for colour values */\r\n\tvar ncycles = 100; /* no. of learning cycles */\r\n\r\n\t/* defs for freq and bias */\r\n\tvar intbiasshift = 16; /* bias for fractions */\r\n\tvar intbias = (1 << intbiasshift);\r\n\tvar gammashift = 10; /* gamma = 1024 */\r\n\tvar gamma = (1 << gammashift);\r\n\tvar betashift = 10;\r\n\tvar beta = (intbias >> betashift); /* beta = 1/1024 */\r\n\tvar betagamma = (intbias << (gammashift - betashift));\r\n\r\n\t/* defs for decreasing radius factor */\r\n\tvar initrad = (netsize >> 3); /* for 256 cols, radius starts */\r\n\tvar radiusbiasshift = 6; /* at 32.0 biased by 6 bits */\r\n\tvar radiusbias = (1 << radiusbiasshift);\r\n\tvar initradius = (initrad * radiusbias); /* and decreases by a */\r\n\tvar radiusdec = 30; /* factor of 1/30 each cycle */\r\n\r\n\t/* defs for decreasing alpha factor */\r\n\tvar alphabiasshift = 10; /* alpha starts at 1.0 */\r\n\tvar initalpha = (1 << alphabiasshift);\r\n\tvar alphadec; /* biased by 10 bits */\r\n\r\n\t/* radbias and alpharadbias used for radpower calculation */\r\n\tvar radbiasshift = 8;\r\n\tvar radbias = (1 << radbiasshift);\r\n\tvar alpharadbshift = (alphabiasshift + radbiasshift);\r\n\tvar alpharadbias = (1 << alpharadbshift);\r\n\r\n\t/*\r\n\t * Types and Global Variables --------------------------\r\n\t */\r\n\r\n\tvar thepicture; /* the input image itself */\r\n\tvar lengthcount; /* lengthcount = H*W*3 */\r\n\tvar samplefac; /* sampling factor 1..30 */\r\n\r\n\t// typedef int pixel[4]; /* BGRc */\r\n\tvar network; /* the network itself - [netsize][4] */\r\n\tvar netindex = [];\r\n\r\n\t/* for network lookup - really 256 */\r\n\tvar bias = [];\r\n\r\n\t/* bias and freq arrays for learning */\r\n\tvar freq = [];\r\n\tvar radpower = [];\r\n\r\n\tvar NeuQuant = exports.NeuQuant = function NeuQuant(thepic, len, sample) {\r\n\r\n\t\tvar i;\r\n\t\tvar p;\r\n\r\n\t\tthepicture = thepic;\r\n\t\tlengthcount = len;\r\n\t\tsamplefac = sample;\r\n\r\n\t\tnetwork = new Array(netsize);\r\n\r\n\t\tfor (i = 0; i < netsize; i++) {\r\n\r\n\t\t\tnetwork[i] = new Array(4);\r\n\t\t\tp = network[i];\r\n\t\t\tp[0] = p[1] = p[2] = (i << (netbiasshift + 8)) / netsize;\r\n\t\t\tfreq[i] = intbias / netsize; /* 1/netsize */\r\n\t\t\tbias[i] = 0;\r\n\t\t}\r\n\t};\r\n\r\n\tvar colorMap = function colorMap() {\r\n\r\n\t\tvar map = [];\r\n\t\tvar index = new Array(netsize);\r\n\r\n\t\tfor (var i = 0; i < netsize; i++)\r\n\t\t\tindex[network[i][3]] = i;\r\n\r\n\t\tvar k = 0;\r\n\t\tfor (var l = 0; l < netsize; l++) {\r\n\t\t\tvar j = index[l];\r\n\t\t\tmap[k++] = (network[j][0]);\r\n\t\t\tmap[k++] = (network[j][1]);\r\n\t\t\tmap[k++] = (network[j][2]);\r\n\t\t}\r\n\r\n\t\treturn map;\r\n\t};\r\n\r\n\t/*\r\n\t * Insertion sort of network and building of netindex[0..255] (to do after\r\n\t * unbias)\r\n\t * -------------------------------------------------------------------------------\r\n\t */\r\n\r\n\tvar inxbuild = function inxbuild() {\r\n\r\n\t\tvar i;\r\n\t\tvar j;\r\n\t\tvar smallpos;\r\n\t\tvar smallval;\r\n\t\tvar p;\r\n\t\tvar q;\r\n\t\tvar previouscol;\r\n\t\tvar startpos;\r\n\r\n\t\tpreviouscol = 0;\r\n\t\tstartpos = 0;\r\n\t\tfor (i = 0; i < netsize; i++) {\r\n\r\n\t\t\tp = network[i];\r\n\t\t\tsmallpos = i;\r\n\t\t\tsmallval = p[1]; /* index on g */\r\n\r\n\t\t\t/* find smallest in i..netsize-1 */\r\n\t\t\tfor (j = i + 1; j < netsize; j++) {\r\n\r\n\t\t\t\tq = network[j];\r\n\t\t\t\tif (q[1] < smallval) { /* index on g */\r\n\t\t\t\t\tsmallpos = j;\r\n\t\t\t\t\tsmallval = q[1]; /* index on g */\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tq = network[smallpos];\r\n\r\n\t\t\t/* swap p (i) and q (smallpos) entries */\r\n\t\t\tif (i != smallpos) {\r\n\t\t\t\tj = q[0];\r\n\t\t\t\tq[0] = p[0];\r\n\t\t\t\tp[0] = j;\r\n\t\t\t\tj = q[1];\r\n\t\t\t\tq[1] = p[1];\r\n\t\t\t\tp[1] = j;\r\n\t\t\t\tj = q[2];\r\n\t\t\t\tq[2] = p[2];\r\n\t\t\t\tp[2] = j;\r\n\t\t\t\tj = q[3];\r\n\t\t\t\tq[3] = p[3];\r\n\t\t\t\tp[3] = j;\r\n\t\t\t}\r\n\r\n\t\t\t/* smallval entry is now in position i */\r\n\r\n\t\t\tif (smallval != previouscol) {\r\n\r\n\t\t\t\tnetindex[previouscol] = (startpos + i) >> 1;\r\n\r\n\t\t\t\tfor (j = previouscol + 1; j < smallval; j++) netindex[j] = i;\r\n\r\n\t\t\t\tpreviouscol = smallval;\r\n\t\t\t\tstartpos = i;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tnetindex[previouscol] = (startpos + maxnetpos) >> 1;\r\n\t\tfor (j = previouscol + 1; j < 256; j++) netindex[j] = maxnetpos; /* really 256 */\r\n\t};\r\n\r\n\t/*\r\n\t * Main Learning Loop ------------------\r\n\t */\r\n\r\n\tvar learn = function learn() {\r\n\r\n\t\tvar i;\r\n\t\tvar j;\r\n\t\tvar b;\r\n\t\tvar g;\r\n\t\tvar r;\r\n\t\tvar radius;\r\n\t\tvar rad;\r\n\t\tvar alpha;\r\n\t\tvar step;\r\n\t\tvar delta;\r\n\t\tvar samplepixels;\r\n\t\tvar p;\r\n\t\tvar pix;\r\n\t\tvar lim;\r\n\r\n\t\tif (lengthcount < minpicturebytes) samplefac = 1;\r\n\r\n\t\talphadec = 30 + ((samplefac - 1) / 3);\r\n\t\tp = thepicture;\r\n\t\tpix = 0;\r\n\t\tlim = lengthcount;\r\n\t\tsamplepixels = lengthcount / (3 * samplefac);\r\n\t\tdelta = (samplepixels / ncycles) | 0;\r\n\t\talpha = initalpha;\r\n\t\tradius = initradius;\r\n\r\n\t\trad = radius >> radiusbiasshift;\r\n\t\tif (rad <= 1) rad = 0;\r\n\r\n\t\tfor (i = 0; i < rad; i++) radpower[i] = alpha * (((rad * rad - i * i) * radbias) / (rad * rad));\r\n\r\n\t\tif (lengthcount < minpicturebytes) step = 3;\r\n\r\n\t\telse if ((lengthcount % prime1) !== 0) step = 3 * prime1;\r\n\r\n\t\telse {\r\n\r\n\t\t\tif ((lengthcount % prime2) !== 0) step = 3 * prime2;\r\n\t\t\telse {\r\n\t\t\t\tif ((lengthcount % prime3) !== 0) step = 3 * prime3;\r\n\t\t\t\telse step = 3 * prime4;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\ti = 0;\r\n\t\twhile (i < samplepixels) {\r\n\r\n\t\t\tb = (p[pix + 0] & 0xff) << netbiasshift;\r\n\t\t\tg = (p[pix + 1] & 0xff) << netbiasshift;\r\n\t\t\tr = (p[pix + 2] & 0xff) << netbiasshift;\r\n\t\t\tj = contest(b, g, r);\r\n\r\n\t\t\taltersingle(alpha, j, b, g, r);\r\n\t\t\tif (rad !== 0) alterneigh(rad, j, b, g, r); /* alter neighbours */\r\n\r\n\t\t\tpix += step;\r\n\t\t\tif (pix >= lim) pix -= lengthcount;\r\n\r\n\t\t\ti++;\r\n\r\n\t\t\tif (delta === 0) delta = 1;\r\n\r\n\t\t\tif (i % delta === 0) {\r\n\t\t\t\talpha -= alpha / alphadec;\r\n\t\t\t\tradius -= radius / radiusdec;\r\n\t\t\t\trad = radius >> radiusbiasshift;\r\n\r\n\t\t\t\tif (rad <= 1) rad = 0;\r\n\r\n\t\t\t\tfor (j = 0; j < rad; j++) radpower[j] = alpha * (((rad * rad - j * j) * radbias) / (rad * rad));\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t/*\r\n\t ** Search for BGR values 0..255 (after net is unbiased) and return colour\r\n\t * index\r\n\t * ----------------------------------------------------------------------------\r\n\t */\r\n\r\n\tvar map = exports.map = function map(b, g, r) {\r\n\r\n\t\tvar i;\r\n\t\tvar j;\r\n\t\tvar dist;\r\n\t\tvar a;\r\n\t\tvar bestd;\r\n\t\tvar p;\r\n\t\tvar best;\r\n\r\n\t\tbestd = 1000; /* biggest possible dist is 256*3 */\r\n\t\tbest = -1;\r\n\t\ti = netindex[g]; /* index on g */\r\n\t\tj = i - 1; /* start at netindex[g] and work outwards */\r\n\r\n\t\twhile ((i < netsize) || (j >= 0)) {\r\n\r\n\t\t\tif (i < netsize) {\r\n\t\t\t\tp = network[i];\r\n\t\t\t\tdist = p[1] - g; /* inx key */\r\n\r\n\t\t\t\tif (dist >= bestd) i = netsize; /* stop iter */\r\n\r\n\t\t\t\telse {\r\n\r\n\t\t\t\t\ti++;\r\n\t\t\t\t\tif (dist < 0) dist = -dist;\r\n\t\t\t\t\ta = p[0] - b;\r\n\t\t\t\t\tif (a < 0) a = -a;\r\n\t\t\t\t\tdist += a;\r\n\r\n\t\t\t\t\tif (dist < bestd) {\r\n\t\t\t\t\t\ta = p[2] - r;\r\n\t\t\t\t\t\tif (a < 0) a = -a;\r\n\t\t\t\t\t\tdist += a;\r\n\r\n\t\t\t\t\t\tif (dist < bestd) {\r\n\t\t\t\t\t\t\tbestd = dist;\r\n\t\t\t\t\t\t\tbest = p[3];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (j >= 0) {\r\n\r\n\t\t\t\tp = network[j];\r\n\t\t\t\tdist = g - p[1]; /* inx key - reverse dif */\r\n\r\n\t\t\t\tif (dist >= bestd) j = -1; /* stop iter */\r\n\r\n\t\t\t\telse {\r\n\r\n\t\t\t\t\tj--;\r\n\t\t\t\t\tif (dist < 0) dist = -dist;\r\n\t\t\t\t\ta = p[0] - b;\r\n\t\t\t\t\tif (a < 0) a = -a;\r\n\t\t\t\t\tdist += a;\r\n\r\n\t\t\t\t\tif (dist < bestd) {\r\n\t\t\t\t\t\ta = p[2] - r;\r\n\t\t\t\t\t\tif (a < 0) a = -a;\r\n\t\t\t\t\t\tdist += a;\r\n\t\t\t\t\t\tif (dist < bestd) {\r\n\t\t\t\t\t\t\tbestd = dist;\r\n\t\t\t\t\t\t\tbest = p[3];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn (best);\r\n\t};\r\n\r\n\tvar process = exports.process = function process() {\r\n\t\tlearn();\r\n\t\tunbiasnet();\r\n\t\tinxbuild();\r\n\t\treturn colorMap();\r\n\t};\r\n\r\n\t/*\r\n\t * Unbias network to give byte values 0..255 and record position i to prepare\r\n\t * for sort\r\n\t * -----------------------------------------------------------------------------------\r\n\t */\r\n\r\n\tvar unbiasnet = function unbiasnet() {\r\n\r\n\t\tvar i;\r\n\t\tvar j;\r\n\r\n\t\tfor (i = 0; i < netsize; i++) {\r\n\t\t\tnetwork[i][0] >>= netbiasshift;\r\n\t\t\tnetwork[i][1] >>= netbiasshift;\r\n\t\t\tnetwork[i][2] >>= netbiasshift;\r\n\t\t\tnetwork[i][3] = i; /* record colour no */\r\n\t\t}\r\n\t};\r\n\r\n\t/*\r\n\t * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in\r\n\t * radpower[|i-j|]\r\n\t * ---------------------------------------------------------------------------------\r\n\t */\r\n\r\n\tvar alterneigh = function alterneigh(rad, i, b, g, r) {\r\n\r\n\t\tvar j;\r\n\t\tvar k;\r\n\t\tvar lo;\r\n\t\tvar hi;\r\n\t\tvar a;\r\n\t\tvar m;\r\n\t\tvar p;\r\n\r\n\t\tlo = i - rad;\r\n\t\tif (lo < -1) lo = -1;\r\n\r\n\t\thi = i + rad;\r\n\t\tif (hi > netsize) hi = netsize;\r\n\r\n\t\tj = i + 1;\r\n\t\tk = i - 1;\r\n\t\tm = 1;\r\n\r\n\t\twhile ((j < hi) || (k > lo)) {\r\n\t\t\ta = radpower[m++];\r\n\r\n\t\t\tif (j < hi) {\r\n\t\t\t\tp = network[j++];\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\tp[0] -= (a * (p[0] - b)) / alpharadbias;\r\n\t\t\t\t\tp[1] -= (a * (p[1] - g)) / alpharadbias;\r\n\t\t\t\t\tp[2] -= (a * (p[2] - r)) / alpharadbias;\r\n\t\t\t\t} catch (e) {} // prevents 1.3 miscompilation\r\n\t\t\t}\r\n\r\n\t\t\tif (k > lo) {\r\n\t\t\t\tp = network[k--];\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\tp[0] -= (a * (p[0] - b)) / alpharadbias;\r\n\t\t\t\t\tp[1] -= (a * (p[1] - g)) / alpharadbias;\r\n\t\t\t\t\tp[2] -= (a * (p[2] - r)) / alpharadbias;\r\n\t\t\t\t} catch (e) {}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t/*\r\n\t * Move neuron i towards biased (b,g,r) by factor alpha\r\n\t * ----------------------------------------------------\r\n\t */\r\n\r\n\tvar altersingle = function altersingle(alpha, i, b, g, r) {\r\n\r\n\t\t/* alter hit neuron */\r\n\t\tvar n = network[i];\r\n\t\tn[0] -= (alpha * (n[0] - b)) / initalpha;\r\n\t\tn[1] -= (alpha * (n[1] - g)) / initalpha;\r\n\t\tn[2] -= (alpha * (n[2] - r)) / initalpha;\r\n\t};\r\n\r\n\t/*\r\n\t * Search for biased BGR values ----------------------------\r\n\t */\r\n\r\n\tvar contest = function contest(b, g, r) {\r\n\r\n\t\t/* finds closest neuron (min dist) and updates freq */\r\n\t\t/* finds best neuron (min dist-bias) and returns position */\r\n\t\t/* for frequently chosen neurons, freq[i] is high and bias[i] is negative */\r\n\t\t/* bias[i] = gamma*((1/netsize)-freq[i]) */\r\n\r\n\t\tvar i;\r\n\t\tvar dist;\r\n\t\tvar a;\r\n\t\tvar biasdist;\r\n\t\tvar betafreq;\r\n\t\tvar bestpos;\r\n\t\tvar bestbiaspos;\r\n\t\tvar bestd;\r\n\t\tvar bestbiasd;\r\n\t\tvar n;\r\n\r\n\t\tbestd = ~ (1 << 31);\r\n\t\tbestbiasd = bestd;\r\n\t\tbestpos = -1;\r\n\t\tbestbiaspos = bestpos;\r\n\r\n\t\tfor (i = 0; i < netsize; i++) {\r\n\t\t\tn = network[i];\r\n\t\t\tdist = n[0] - b;\r\n\t\t\tif (dist < 0) dist = -dist;\r\n\t\t\ta = n[1] - g;\r\n\t\t\tif (a < 0) a = -a;\r\n\t\t\tdist += a;\r\n\t\t\ta = n[2] - r;\r\n\t\t\tif (a < 0) a = -a;\r\n\t\t\tdist += a;\r\n\r\n\t\t\tif (dist < bestd) {\r\n\t\t\t\tbestd = dist;\r\n\t\t\t\tbestpos = i;\r\n\t\t\t}\r\n\r\n\t\t\tbiasdist = dist - ((bias[i]) >> (intbiasshift - netbiasshift));\r\n\r\n\t\t\tif (biasdist < bestbiasd) {\r\n\t\t\t\tbestbiasd = biasdist;\r\n\t\t\t\tbestbiaspos = i;\r\n\t\t\t}\r\n\r\n\t\t\tbetafreq = (freq[i] >> betashift);\r\n\t\t\tfreq[i] -= betafreq;\r\n\t\t\tbias[i] += (betafreq << gammashift);\r\n\t\t}\r\n\r\n\t\tfreq[bestpos] += beta;\r\n\t\tbias[bestpos] -= betagamma;\r\n\t\treturn (bestbiaspos);\r\n\t};\r\n\r\n\tNeuQuant.apply(this, arguments);\r\n\treturn exports;\r\n};\r\n","/**\r\n * This class lets you encode animated GIF files\r\n * Base class :  http://www.java2s.com/Code/Java/2D-Graphics-GUI/AnimatedGifEncoder.htm\r\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\r\n * @author Thibault Imbert (AS3 version - bytearray.org)\r\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\r\n * @version 0.1 AS3 implementation\r\n */\r\n\r\nGIFEncoder = function() {\r\n\r\n\tfor (var i = 0, chr = {}; i < 256; i++)\r\n\t\tchr[i] = String.fromCharCode(i);\r\n\r\n\tfunction ByteArray() {\r\n\t\tthis.bin = [];\r\n\t}\r\n\r\n\tByteArray.prototype.getData = function() {\r\n\t\tfor (var v = '', l = this.bin.length, i = 0; i < l; i++)\r\n\t\t\tv += chr[this.bin[i]];\r\n\t\treturn v;\r\n\t};\r\n\r\n\tByteArray.prototype.writeByte = function(val) {\r\n\t\tthis.bin.push(val);\r\n\t};\r\n\r\n\tByteArray.prototype.writeUTFBytes = function(string) {\r\n\t\tfor (var l = string.length, i = 0; i < l; i++)\r\n\t\t\tthis.writeByte(string.charCodeAt(i));\r\n\t};\r\n\r\n\tByteArray.prototype.writeBytes = function(array, offset, length) {\r\n\t\tfor (var l = length || array.length, i = offset || 0; i < l; i++)\r\n\t\t\tthis.writeByte(array[i]);\r\n\t};\r\n\r\n\tvar exports = {};\r\n\tvar width; // image size\r\n\tvar height;\r\n\tvar transparent = null; // transparent color if given\r\n\tvar transIndex; // transparent index in color table\r\n\tvar repeat = -1; // no repeat\r\n\tvar delay = 0; // frame delay (hundredths)\r\n\tvar started = false; // ready to output frames\r\n\tvar out;\r\n\tvar image; // current frame\r\n\tvar pixels; // BGR byte array from frame\r\n\tvar indexedPixels; // converted frame indexed to palette\r\n\tvar colorDepth; // number of bit planes\r\n\tvar colorTab; // RGB palette\r\n\tvar usedEntry = []; // active palette entries\r\n\tvar palSize = 7; // color table size (bits-1)\r\n\tvar dispose = -1; // disposal code (-1 = use default)\r\n\tvar closeStream = false; // close stream when finished\r\n\tvar firstFrame = true;\r\n\tvar sizeSet = false; // if false, get size from first frame\r\n\tvar sample = 10; // default sample interval for quantizer\r\n\tvar comment = \"Generated by jsgif (https://github.com/antimatter15/jsgif/)\"; // default comment for generated gif\r\n\r\n\t/**\r\n\t * Sets the delay time between each frame, or changes it for subsequent frames\r\n\t * (applies to last frame added)\r\n\t * int delay time in milliseconds\r\n\t * @param ms\r\n\t */\r\n\r\n\tvar setDelay = exports.setDelay = function setDelay(ms) {\r\n\t\tdelay = Math.round(ms / 10);\r\n\t};\r\n\r\n\t/**\r\n\t * Sets the GIF frame disposal code for the last added frame and any\r\n\t *\r\n\t * subsequent frames. Default is 0 if no transparent color has been set,\r\n\t * otherwise 2.\r\n\t * @param code\r\n\t * int disposal code.\r\n\t */\r\n\r\n\tvar setDispose = exports.setDispose = function setDispose(code) {\r\n\t\tif (code >= 0) dispose = code;\r\n\t};\r\n\r\n\t/**\r\n\t * Sets the number of times the set of GIF frames should be played. Default is\r\n\t * 1; 0 means play indefinitely. Must be invoked before the first image is\r\n\t * added.\r\n\t *\r\n\t * @param iter\r\n\t * int number of iterations.\r\n\t * @return\r\n\t */\r\n\r\n\tvar setRepeat = exports.setRepeat = function setRepeat(iter) {\r\n\t\tif (iter >= 0) repeat = iter;\r\n\t};\r\n\r\n\t/**\r\n\t * Sets the transparent color for the last added frame and any subsequent\r\n\t * frames. Since all colors are subject to modification in the quantization\r\n\t * process, the color in the final palette for each frame closest to the given\r\n\t * color becomes the transparent color for that frame. May be set to null to\r\n\t * indicate no transparent color.\r\n\t * @param\r\n\t * Color to be treated as transparent on display.\r\n\t */\r\n\r\n\tvar setTransparent = exports.setTransparent = function setTransparent(c) {\r\n\t\ttransparent = c;\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Sets the comment for the block comment\r\n\t * @param\r\n\t * string to be insterted as comment\r\n\t */\r\n\r\n\tvar setComment = exports.setComment = function setComment(c) {\r\n\t\tcomment = c;\r\n\t};\r\n\r\n\r\n\r\n\t/**\r\n\t * The addFrame method takes an incoming BitmapData object to create each frames\r\n\t * @param\r\n\t * BitmapData object to be treated as a GIF's frame\r\n\t */\r\n\r\n\tvar addFrame = exports.addFrame = function addFrame(im, is_imageData) {\r\n\r\n\t\tif ((im === null) || !started || out === null) {\r\n\t\t\tthrow new Error(\"Please call start method before calling addFrame\");\r\n\t\t}\r\n\r\n\t\tvar ok = true;\r\n\r\n\t\ttry {\r\n\t\t\tif (!is_imageData) {\r\n\t\t\t\timage = im.getImageData(0, 0, im.canvas.width, im.canvas.height).data;\r\n\t\t\t\tif (!sizeSet) setSize(im.canvas.width, im.canvas.height);\r\n\t\t\t} else {\r\n\t\t\t\tif(im instanceof ImageData) {\r\n\t\t\t\t\timage = im.data;\r\n\t\t\t\t\tif(!sizeSet || width!=im.width || height!=im.height) {\r\n\t\t\t\t\t\tsetSize(im.width,im.height);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if(im instanceof Uint8ClampedArray) {\r\n\t\t\t\t\tif(im.length==(width*height*4)) {\r\n\t\t\t\t\t\timage=im;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tconsole.log(\"Please set the correct size: ImageData length mismatch\");\r\n\t\t\t\t\t\tok=false;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconsole.log(\"Please provide correct input\");\r\n\t\t\t\t\tok=false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tgetImagePixels(); // convert to correct format if necessary\r\n\t\t\tanalyzePixels(); // build color table & map pixels\r\n\r\n\t\t\tif (firstFrame) {\r\n\t\t\t\twriteLSD(); // logical screen descriptior\r\n\t\t\t\twritePalette(); // global color table\r\n\t\t\t\tif (repeat >= 0) {\r\n\t\t\t\t\t// use NS app extension to indicate reps\r\n\t\t\t\t\twriteNetscapeExt();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\twriteGraphicCtrlExt(); // write graphic control extension\r\n\t\t\tif (comment !== '') {\r\n\t\t\t\twriteCommentExt(); // write comment extension\r\n\t\t\t}\r\n\t\t\twriteImageDesc(); // image descriptor\r\n\t\t\tif (!firstFrame) writePalette(); // local color table\r\n\t\t\twritePixels(); // encode and write pixel data\r\n\t\t\tfirstFrame = false;\r\n\t\t} catch (e) {\r\n\t\t\tok = false;\r\n\t\t}\r\n\r\n\t\treturn ok;\r\n\t};\r\n\t\r\n\t/**\r\n\t* @description: Downloads the encoded gif with the given name\r\n\t* No need of any conversion from the stream data (out) to base64\r\n\t* Solves the issue of large file sizes when there are more frames\r\n\t* and does not involve in creation of any temporary data in the process\r\n\t* so no wastage of memory, and speeds up the process of downloading\r\n\t* to just calling this function.\r\n\t* @parameter {String} filename filename used for downloading the gif\r\n\t*/\r\n\t\r\n\tvar download = exports.download = function download(filename) {\r\n\t\tif(out===null || closeStream==false) {\r\n\t\t\tconsole.log(\"Please call start method and add frames and call finish method before calling download\"); \r\n\t\t} else {\r\n\t\t\tfilename= filename !== undefined ? ( filename.endsWith(\".gif\")? filename: filename+\".gif\" ): \"download.gif\";\r\n\t\t\tvar templink = document.createElement(\"a\");\r\n\t\t\ttemplink.download=filename;\r\n\t\t\ttemplink.href= URL.createObjectURL(new Blob([new Uint8Array(out.bin)], {type : \"image/gif\" } ));\r\n\t\t\ttemplink.click();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Adds final trailer to the GIF stream, if you don't call the finish method\r\n\t * the GIF stream will not be valid.\r\n\t */\r\n\r\n\tvar finish = exports.finish = function finish() {\r\n\r\n\t\tif (!started) return false;\r\n\r\n\t\tvar ok = true;\r\n\t\tstarted = false;\r\n\r\n\t\ttry {\r\n\t\t\tout.writeByte(0x3b); // gif trailer\r\n\t\t\tcloseStream=true;\r\n\t\t} catch (e) {\r\n\t\t\tok = false;\r\n\t\t}\r\n\r\n\t\treturn ok;\r\n\t};\r\n\r\n\t/**\r\n\t * Resets some members so that a new stream can be started.\r\n\t * This method is actually called by the start method\r\n\t */\r\n\r\n\tvar reset = function reset() {\r\n\r\n\t\t// reset for subsequent use\r\n\t\ttransIndex = 0;\r\n\t\timage = null;\r\n\t\tpixels = null;\r\n\t\tindexedPixels = null;\r\n\t\tcolorTab = null;\r\n\t\tcloseStream = false;\r\n\t\tfirstFrame = true;\r\n\t};\r\n\r\n\t/**\r\n\t * * Sets frame rate in frames per second. Equivalent to\r\n\t * <code>setDelay(1000/fps)</code>.\r\n\t * @param fps\r\n\t * float frame rate (frames per second)\r\n\t */\r\n\r\n\tvar setFrameRate = exports.setFrameRate = function setFrameRate(fps) {\r\n\t\tif (fps != 0xf) delay = Math.round(100 / fps);\r\n\t};\r\n\r\n\t/**\r\n\t * Sets quality of color quantization (conversion of images to the maximum 256\r\n\t * colors allowed by the GIF specification). Lower values (minimum = 1)\r\n\t * produce better colors, but slow processing significantly. 10 is the\r\n\t * default, and produces good color mapping at reasonable speeds. Values\r\n\t * greater than 20 do not yield significant improvements in speed.\r\n\t * @param quality\r\n\t * int greater than 0.\r\n\t * @return\r\n\t */\r\n\r\n\tvar setQuality = exports.setQuality = function setQuality(quality) {\r\n\t\tif (quality < 1) quality = 1;\r\n\t\tsample = quality;\r\n\t};\r\n\r\n\t/**\r\n\t * Sets the GIF frame size. The default size is the size of the first frame\r\n\t * added if this method is not invoked.\r\n\t * @param w\r\n\t * int frame width.\r\n\t * @param h\r\n\t * int frame width.\r\n\t */\r\n\r\n\tvar setSize = exports.setSize = function setSize(w, h) {\r\n\r\n\t\tif (started && !firstFrame) return;\r\n\t\twidth = w;\r\n\t\theight = h;\r\n\t\tif (width < 1) width = 320;\r\n\t\tif (height < 1) height = 240;\r\n\t\tsizeSet = true;\r\n\t};\r\n\r\n\t/**\r\n\t * Initiates GIF file creation on the given stream.\r\n\t * @param os\r\n\t * OutputStream on which GIF images are written.\r\n\t * @return false if initial write failed.\r\n\t */\r\n\r\n\tvar start = exports.start = function start() {\r\n\r\n\t\treset();\r\n\t\tvar ok = true;\r\n\t\tcloseStream = false;\r\n\t\tout = new ByteArray();\r\n\t\ttry {\r\n\t\t\tout.writeUTFBytes(\"GIF89a\"); // header\r\n\t\t} catch (e) {\r\n\t\t\tok = false;\r\n\t\t}\r\n\r\n\t\treturn started = ok;\r\n\t};\r\n\r\n\tvar cont = exports.cont = function cont() {\r\n\r\n\t\treset();\r\n\t\tvar ok = true;\r\n\t\tcloseStream = false;\r\n\t\tout = new ByteArray();\r\n\r\n\t\treturn started = ok;\r\n\t};\r\n\r\n\t/**\r\n\t * Analyzes image colors and creates color map.\r\n\t */\r\n\r\n\tvar analyzePixels = function analyzePixels() {\r\n\r\n\t\tvar len = pixels.length;\r\n\t\tvar nPix = len / 3;\r\n\t\tindexedPixels = [];\r\n\t\tvar nq = new NeuQuant(pixels, len, sample);\r\n\r\n\t\t// initialize quantizer\r\n\t\tcolorTab = nq.process(); // create reduced palette\r\n\r\n\t\t// map image pixels to new palette\r\n\t\tvar k = 0;\r\n\t\tfor (var j = 0; j < nPix; j++) {\r\n\t\t\tvar index = nq.map(pixels[k++] & 0xff, pixels[k++] & 0xff, pixels[k++] & 0xff);\r\n\t\t\tusedEntry[index] = true;\r\n\t\t\tindexedPixels[j] = index;\r\n\t\t}\r\n\r\n\t\tpixels = null;\r\n\t\tcolorDepth = 8;\r\n\t\tpalSize = 7;\r\n\r\n\t\t// get closest match to transparent color if specified\r\n\t\tif (transparent !== null) {\r\n\t\t\ttransIndex = findClosest(transparent);\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Returns index of palette color closest to c\r\n\t */\r\n\r\n\tvar findClosest = function findClosest(c) {\r\n\r\n\t\tif (colorTab === null) return -1;\r\n\t\tvar r = (c & 0xFF0000) >> 16;\r\n\t\tvar g = (c & 0x00FF00) >> 8;\r\n\t\tvar b = (c & 0x0000FF);\r\n\t\tvar minpos = 0;\r\n\t\tvar dmin = 256 * 256 * 256;\r\n\t\tvar len = colorTab.length;\r\n\r\n\t\tfor (var i = 0; i < len;) {\r\n\t\t\tvar dr = r - (colorTab[i++] & 0xff);\r\n\t\t\tvar dg = g - (colorTab[i++] & 0xff);\r\n\t\t\tvar db = b - (colorTab[i] & 0xff);\r\n\t\t\tvar d = dr * dr + dg * dg + db * db;\r\n\t\t\tvar index = i / 3;\r\n\t\t\tif (usedEntry[index] && (d < dmin)) {\r\n\t\t\t\tdmin = d;\r\n\t\t\t\tminpos = index;\r\n\t\t\t}\r\n\t\t\ti++;\r\n\t\t}\r\n\t\treturn minpos;\r\n\t};\r\n\r\n\t/**\r\n\t * Extracts image pixels into byte array \"pixels\r\n\t */\r\n\r\n\tvar getImagePixels = function getImagePixels() {\r\n\t\tvar w = width;\r\n\t\tvar h = height;\r\n\t\tpixels = [];\r\n\t\tvar data = image;\r\n\t\tvar count = 0;\r\n\r\n\t\tfor (var i = 0; i < h; i++) {\r\n\r\n\t\t\tfor (var j = 0; j < w; j++) {\r\n\r\n\t\t\t\tvar b = (i * w * 4) + j * 4;\r\n\t\t\t\tpixels[count++] = data[b];\r\n\t\t\t\tpixels[count++] = data[b + 1];\r\n\t\t\t\tpixels[count++] = data[b + 2];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Writes Graphic Control Extension\r\n\t */\r\n\r\n\tvar writeGraphicCtrlExt = function writeGraphicCtrlExt() {\r\n\t\tout.writeByte(0x21); // extension introducer\r\n\t\tout.writeByte(0xf9); // GCE label\r\n\t\tout.writeByte(4); // data block size\r\n\t\tvar transp;\r\n\t\tvar disp;\r\n\t\tif (transparent === null) {\r\n\t\t\ttransp = 0;\r\n\t\t\tdisp = 0; // dispose = no action\r\n\t\t} else {\r\n\t\t\ttransp = 1;\r\n\t\t\tdisp = 2; // force clear if using transparent color\r\n\t\t}\r\n\t\tif (dispose >= 0) {\r\n\t\t\tdisp = dispose & 7; // user override\r\n\t\t}\r\n\t\tdisp <<= 2;\r\n\t\t// packed fields\r\n\t\tout.writeByte(0 | // 1:3 reserved\r\n\t\t\tdisp | // 4:6 disposal\r\n\t\t\t0 | // 7 user input - 0 = none\r\n\t\t\ttransp); // 8 transparency flag\r\n\r\n\t\tWriteShort(delay); // delay x 1/100 sec\r\n\t\tout.writeByte(transIndex); // transparent color index\r\n\t\tout.writeByte(0); // block terminator\r\n\t};\r\n\r\n\t/**\r\n\t * Writes Comment Extention\r\n\t */\r\n\r\n\tvar writeCommentExt = function writeCommentExt() {\r\n\t\tout.writeByte(0x21); // extension introducer\r\n\t\tout.writeByte(0xfe); // comment label\r\n\t\tout.writeByte(comment.length); // Block Size (s)\r\n\t\tout.writeUTFBytes(comment);\r\n\t\tout.writeByte(0); // block terminator\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Writes Image Descriptor\r\n\t */\r\n\r\n\tvar writeImageDesc = function writeImageDesc() {\r\n\r\n\t\tout.writeByte(0x2c); // image separator\r\n\t\tWriteShort(0); // image position x,y = 0,0\r\n\t\tWriteShort(0);\r\n\t\tWriteShort(width); // image size\r\n\t\tWriteShort(height);\r\n\r\n\t\t// packed fields\r\n\t\tif (firstFrame) {\r\n\t\t\t// no LCT - GCT is used for first (or only) frame\r\n\t\t\tout.writeByte(0);\r\n\t\t} else {\r\n\t\t\t// specify normal LCT\r\n\t\t\tout.writeByte(0x80 | // 1 local color table 1=yes\r\n\t\t\t\t0 | // 2 interlace - 0=no\r\n\t\t\t\t0 | // 3 sorted - 0=no\r\n\t\t\t\t0 | // 4-5 reserved\r\n\t\t\t\tpalSize); // 6-8 size of color table\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Writes Logical Screen Descriptor\r\n\t */\r\n\r\n\tvar writeLSD = function writeLSD() {\r\n\r\n\t\t// logical screen size\r\n\t\tWriteShort(width);\r\n\t\tWriteShort(height);\r\n\t\t// packed fields\r\n\t\tout.writeByte((0x80 | // 1 : global color table flag = 1 (gct used)\r\n\t\t\t0x70 | // 2-4 : color resolution = 7\r\n\t\t\t0x00 | // 5 : gct sort flag = 0\r\n\t\t\tpalSize)); // 6-8 : gct size\r\n\r\n\t\tout.writeByte(0); // background color index\r\n\t\tout.writeByte(0); // pixel aspect ratio - assume 1:1\r\n\t};\r\n\r\n\t/**\r\n\t * Writes Netscape application extension to define repeat count.\r\n\t */\r\n\r\n\tvar writeNetscapeExt = function writeNetscapeExt() {\r\n\t\tout.writeByte(0x21); // extension introducer\r\n\t\tout.writeByte(0xff); // app extension label\r\n\t\tout.writeByte(11); // block size\r\n\t\tout.writeUTFBytes(\"NETSCAPE\" + \"2.0\"); // app id + auth code\r\n\t\tout.writeByte(3); // sub-block size\r\n\t\tout.writeByte(1); // loop sub-block id\r\n\t\tWriteShort(repeat); // loop count (extra iterations, 0=repeat forever)\r\n\t\tout.writeByte(0); // block terminator\r\n\t};\r\n\r\n\t/**\r\n\t * Writes color table\r\n\t */\r\n\r\n\tvar writePalette = function writePalette() {\r\n\t\tout.writeBytes(colorTab);\r\n\t\tvar n = (3 * 256) - colorTab.length;\r\n\t\tfor (var i = 0; i < n; i++) out.writeByte(0);\r\n\t};\r\n\r\n\tvar WriteShort = function WriteShort(pValue) {\r\n\t\tout.writeByte(pValue & 0xFF);\r\n\t\tout.writeByte((pValue >> 8) & 0xFF);\r\n\t};\r\n\r\n\t/**\r\n\t * Encodes and writes pixel data\r\n\t */\r\n\r\n\tvar writePixels = function writePixels() {\r\n\t\tvar myencoder = new LZWEncoder(width, height, indexedPixels, colorDepth);\r\n\t\tmyencoder.encode(out);\r\n\t};\r\n\r\n\t/**\r\n\t * Retrieves the GIF stream\r\n\t */\r\n\r\n\tvar stream = exports.stream = function stream() {\r\n\t\treturn out;\r\n\t};\r\n\r\n\tvar setProperties = exports.setProperties = function setProperties(has_start, is_first) {\r\n\t\tstarted = has_start;\r\n\t\tfirstFrame = is_first;\r\n\t};\r\n\r\n\treturn exports;\r\n\r\n};\r\n","import { FrameData, GIFEncoder } from \"../models\";\r\n\r\nexport default class Hat {\r\n  public async augment(frames: FrameData[], ctx: OffscreenCanvasRenderingContext2D, encoder: GIFEncoder) {\r\n    const { hatWidth, hatHeight } = this.calculateHatSize(frames)\r\n\r\n    for (const { frame, pose } of frames) {\r\n      const bitmap = await createImageBitmap(frame);\r\n      ctx.drawImage(bitmap, 0, 0, ctx.canvas.width, ctx.canvas.height);\r\n\r\n      const rightHand = pose.keypoints.find(({ name }) => name === 'right_wrist');\r\n      if (rightHand) {\r\n        ctx.fillRect(rightHand.x + hatWidth / 2, rightHand.y - hatHeight, hatWidth, hatHeight);\r\n      }\r\n\r\n      encoder.addFrame(ctx, false);\r\n    }\r\n  }\r\n\r\n  private calculateHatSize(frames: FrameData[]) {\r\n    let hatWidth = 40;\r\n    let hatHeight = 20;\r\n\r\n    for (const { pose } of frames) {\r\n      const leftEye = pose.keypoints.find(({ name }) => name === 'left_eye');\r\n      if (!leftEye) {\r\n        continue;\r\n      }\r\n\r\n      const rightEye = pose.keypoints.find(({ name }) => name === 'right_eye');\r\n      if (!rightEye) {\r\n        continue;\r\n      }\r\n\r\n      hatWidth = Math.abs(leftEye.x - rightEye.x) * 2;\r\n      hatHeight = hatWidth;\r\n      return { hatWidth, hatHeight }\r\n    }\r\n\r\n    return { hatWidth, hatHeight };\r\n  }\r\n}","import './js/LZWEncoder.js';\r\nimport './js/NeuQuant.js';\r\nimport './js/GIFEncoder.js';\r\n\r\nimport { GIFEncoder } from './models';\r\nimport Hat from './movement-augmenters/hat';\r\n\r\n// TODO: https://github.com/microsoft/TypeScript/issues/20595\r\nconst worker: Worker = self as unknown as Worker;\r\nlet ctx: OffscreenCanvasRenderingContext2D = undefined;\r\nlet width: number = undefined;\r\nlet height: number = undefined;\r\nlet augmenter = new Hat();\r\n\r\nconst encoder: GIFEncoder = new (self as any).GIFEncoder(); //create a new GIFEncoder for every new job\r\nencoder.setRepeat(0);\r\nencoder.start();\r\n\r\nworker.addEventListener('message', async ({ data }) => {\r\n  switch (data.type) {\r\n    case 'gif:setOptions':\r\n      width = data.width;\r\n      height = data.height;\r\n\r\n      encoder.setSize(width, height);\r\n      encoder.setDelay(data.delay);\r\n\r\n      const offscreen = new OffscreenCanvas(width, height);\r\n      ctx = offscreen.getContext('2d');\r\n      break;\r\n    case 'gif:addFrames':\r\n      ctx.fillStyle = 'lightgreen';\r\n\r\n      await augmenter.augment(data.frames, ctx, encoder);\r\n\r\n      encoder.finish();\r\n\r\n      const { bin } = encoder.stream();\r\n      const url = URL.createObjectURL(new Blob([new Uint8Array(bin)], { type: \"image/gif\" }));\r\n\r\n      worker.postMessage({ type: 'gif:url', url });\r\n\r\n      encoder.start();\r\n      break;\r\n    default: throw new Error(`unexpected message type: ${data.type}`)\r\n  }\r\n});\r\n"]}